<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Sierpinski Gasket 交互演示</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .description {
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .canvas-container {
            flex: 1;
            min-width: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
        }
        
        .controls {
            flex: 0 0 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        canvas {
            width: 100%;
            height: 500px;
            background: #000;
            border-radius: 5px;
            display: block;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 8px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        select, input[type="range"] {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            margin-bottom: 15px;
        }
        
        input[type="range"] {
            padding: 0;
            height: 30px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .checkbox-group input {
            margin-right: 10px;
            transform: scale(1.2);
        }
        
        .value-display {
            display: flex;
            justify-content: space-between;
            margin-top: -10px;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }
        
        button {
            width: 100%;
            padding: 12px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background 0.3s;
            margin-top: 10px;
        }
        
        button:hover {
            background: #3a7bc8;
        }
        
        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .info-panel h2 {
            margin-bottom: 15px;
        }
        
        .info-panel p {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        @media (max-width: 900px) {
            .content {
                flex-direction: column;
            }
            
            .canvas-container, .controls {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>WebGL Sierpinski Gasket 交互演示</h1>
            <p class="description">
                此演示展示了五种不同的Sierpinski Gasket实现方法：点模式、三角形模式、彩色点模式、3D四面体模式和三角形细分模式。
                您可以通过下面的控件切换不同演示并调整参数。
            </p>
        </header>
        
        <div class="content">
            <div class="canvas-container">
                <h2 id="demo-title">Gasket Points</h2>
                <canvas id="gl-canvas" width="512" height="512">
                    您的浏览器不支持HTML5 canvas元素
                </canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h2>演示选择</h2>
                    <label for="demo-select">选择演示类型:</label>
                    <select id="demo-select">
                        <option value="points">点模式 Sierpinski Gasket</option>
                        <option value="triangles">三角形模式 Sierpinski Gasket</option>
                        <option value="color">彩色点模式 Sierpinski Gasket</option>
                        <option value="3d">3D Sierpinski Gasket</option>
                        <option value="tessellation">三角形细分</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <h2>参数控制</h2>
                    
                    <div id="points-controls">
                        <label for="points-count">点的数量:</label>
                        <input type="range" id="points-count" min="100" max="10000" value="5000" step="100">
                        <div class="value-display">
                            <span>100</span>
                            <span id="points-count-value">5000</span>
                            <span>10000</span>
                        </div>
                    </div>
                    
                    <div id="subdivision-controls">
                        <label for="subdivision-level">细分级别:</label>
                        <input type="range" id="subdivision-level" min="0" max="6" value="3" step="1">
                        <div class="value-display">
                            <span>0</span>
                            <span id="subdivision-level-value">3</span>
                            <span>6</span>
                        </div>
                    </div>
                    
                    <div id="tessellation-controls">
                        <label for="theta">旋转角度 (θ):</label>
                        <input type="range" id="theta" min="0" max="180" value="60" step="1">
                        <div class="value-display">
                            <span>0°</span>
                            <span id="theta-value">60°</span>
                            <span>180°</span>
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="twist">
                            <label for="twist">启用扭曲效果</label>
                        </div>
                    </div>
                </div>
                
                <button id="reset-button">重置参数</button>
            </div>
        </div>
        
        <div class="info-panel">
            <h2>关于 Sierpinski Gasket</h2>
            <p>Sierpinski Gasket（谢尔宾斯基三角形）是一种分形图案，由波兰数学家Wacław Sierpiński在1915年描述。</p>
            <p>它可以通过不断将三角形分割为更小的三角形来创建，或者通过随机迭代函数系统（IFS）生成。</p>
            <p>这个演示展示了使用WebGL（Web Graphics Library）在浏览器中实时渲染Sierpinski Gasket的多种方法。</p>
        </div>
    </div>

    <!-- 着色器脚本 -->
    <script id="vertex-shader-points" type="x-shader/x-vertex">
        #version 300 es
        in vec4 vPosition;
        void main(){
            gl_PointSize = 3.0;
            gl_Position = vPosition;
        }
    </script>

    <script id="fragment-shader-points" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
        out vec4 fColor;
        void main(){
            fColor = vec4( 1.0, 0.0, 0.0, 1.0 );
        }
    </script>

    <script id="vertex-shader-triangles" type="x-shader/x-vertex">
        #version 300 es
        in vec4 vPosition;
        void main(){
            gl_Position = vPosition;
        }
    </script>

    <script id="fragment-shader-triangles" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
        out vec4 fColor;
        void main(){
            fColor = vec4( 1.0, 0.0, 0.0, 1.0 );
        }
    </script>

    <script id="vertex-shader-color" type="x-shader/x-vertex">
        #version 300 es
        in vec4 vPosition;
        out vec4 vColor;
        void main(){
            gl_Position = vPosition;
            gl_PointSize = 2.0;
            vColor = vec4((1.0+vPosition.xyz)/2.0, 1.0);
        }
    </script>

    <script id="fragment-shader-color" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
        in vec4 vColor;
        out vec4 fColor;
        void main(){
            fColor= vColor;
        }
    </script>

    <script id="vertex-shader-3d" type="x-shader/x-vertex">
        #version 300 es
        in vec3 vPosition;
        in vec4 aColor;
        out vec4 vColor;

        void main(){
            gl_Position = vec4( vPosition, 1.0 );
            vColor = aColor;
        }
    </script>

    <script id="fragment-shader-3d" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
        
        in vec4 vColor;
        out vec4 fColor;
        void main(){
            fColor = vColor;
        }
    </script>

    <script id="vertex-shader-tessellation" type="x-shader/x-vertex">
        #version 300 es
        in vec4 vPosition;
        void main(){
            gl_Position = vPosition;
        }
    </script>

    <script id="fragment-shader-tessellation" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
        out vec4 fColor;
        void main(){
            fColor = vec4( 1.0, 0.0, 0.0, 1.0 );
        }
    </script>

    <!-- 外部库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    
    <!-- 主应用程序 -->
    <script>
        "use strict";

        // 全局变量
        let gl, canvas;
        let currentDemo = 'points';
        let program;
        
        // 演示参数
        const params = {
            points: {
                numPoints: 5000
            },
            triangles: {
                numTimesToSubdivide: 3
            },
            color: {
                numPoints: 5000
            },
            '3d': {
                numTimesToSubdivide: 3
            },
            tessellation: {
                numTimesToSubdivide: 0,
                theta: 60,
                twist: false,
                radius: 1.0
            }
        };

        // 初始化函数
        window.onload = function init() {
            canvas = document.getElementById("gl-canvas");
            
            // 获取WebGL2上下文
            gl = canvas.getContext("webgl2");
            if (!gl) {
                alert("WebGL 2.0 不可用");
                return;
            }
            
            // 设置初始演示
            setupDemo('points');
            
            // 设置事件监听器
            setupEventListeners();
        };

        // 设置事件监听器
        function setupEventListeners() {
            // 演示选择
            document.getElementById('demo-select').addEventListener('change', function(e) {
                setupDemo(e.target.value);
            });
            
            // 参数控制
            document.getElementById('points-count').addEventListener('input', function(e) {
                const value = parseInt(e.target.value);
                document.getElementById('points-count-value').textContent = value;
                params.points.numPoints = value;
                params.color.numPoints = value;
                if (currentDemo === 'points' || currentDemo === 'color') {
                    setupDemo(currentDemo);
                }
            });
            
            document.getElementById('subdivision-level').addEventListener('input', function(e) {
                const value = parseInt(e.target.value);
                document.getElementById('subdivision-level-value').textContent = value;
                params.triangles.numTimesToSubdivide = value;
                params['3d'].numTimesToSubdivide = value;
                if (currentDemo === 'triangles' || currentDemo === '3d') {
                    setupDemo(currentDemo);
                }
            });
            
            document.getElementById('theta').addEventListener('input', function(e) {
                const value = parseInt(e.target.value);
                document.getElementById('theta-value').textContent = value + '°';
                params.tessellation.theta = value;
                if (currentDemo === 'tessellation') {
                    setupDemo(currentDemo);
                }
            });
            
            document.getElementById('twist').addEventListener('change', function(e) {
                params.tessellation.twist = e.target.checked;
                if (currentDemo === 'tessellation') {
                    setupDemo(currentDemo);
                }
            });
            
            // 重置按钮
            document.getElementById('reset-button').addEventListener('click', function() {
                resetParams();
                setupDemo(currentDemo);
            });
        }

        // 重置参数
        function resetParams() {
            params.points.numPoints = 5000;
            params.triangles.numTimesToSubdivide = 3;
            params.color.numPoints = 5000;
            params['3d'].numTimesToSubdivide = 3;
            params.tessellation.numTimesToSubdivide = 0;
            params.tessellation.theta = 60;
            params.tessellation.twist = false;
            
            // 更新UI
            document.getElementById('points-count').value = 5000;
            document.getElementById('points-count-value').textContent = '5000';
            document.getElementById('subdivision-level').value = 3;
            document.getElementById('subdivision-level-value').textContent = '3';
            document.getElementById('theta').value = 60;
            document.getElementById('theta-value').textContent = '60°';
            document.getElementById('twist').checked = false;
        }

        // 设置演示
        function setupDemo(demoType) {
            currentDemo = demoType;
            
            // 更新标题
            const titles = {
                points: '点模式 Sierpinski Gasket',
                triangles: '三角形模式 Sierpinski Gasket',
                color: '彩色点模式 Sierpinski Gasket',
                '3d': '3D Sierpinski Gasket',
                tessellation: '三角形细分'
            };
            document.getElementById('demo-title').textContent = titles[demoType];
            
            // 显示/隐藏相关控件
            document.getElementById('points-controls').style.display = 
                (demoType === 'points' || demoType === 'color') ? 'block' : 'none';
            document.getElementById('subdivision-controls').style.display = 
                (demoType === 'triangles' || demoType === '3d') ? 'block' : 'none';
            document.getElementById('tessellation-controls').style.display = 
                demoType === 'tessellation' ? 'block' : 'none';
            
            // 设置WebGL
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(1.0, 1.0, 1.0, 1.0);
            
            // 根据演示类型调用相应的初始化函数
            switch(demoType) {
                case 'points':
                    initPointsDemo();
                    break;
                case 'triangles':
                    initTrianglesDemo();
                    break;
                case 'color':
                    initColorDemo();
                    break;
                case '3d':
                    init3dDemo();
                    break;
                case 'tessellation':
                    initTessellationDemo();
                    break;
            }
        }

        // 初始化着色器程序
        function initShaderProgram(vertexShaderId, fragmentShaderId) {
            const vertexShaderSource = document.getElementById(vertexShaderId).text;
            const fragmentShaderSource = document.getElementById(fragmentShaderId).text;
            
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);
            
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error('顶点着色器编译错误:', gl.getShaderInfoLog(vertexShader));
                return null;
            }
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);
            
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error('片段着色器编译错误:', gl.getShaderInfoLog(fragmentShader));
                return null;
            }
            
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('着色器程序链接错误:', gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            
            return shaderProgram;
        }

        // 点模式演示
        function initPointsDemo() {
            program = initShaderProgram('vertex-shader-points', 'fragment-shader-points');
            if (!program) return;
            
            gl.useProgram(program);
            
            const { vec3 } = glMatrix;
            const points = [];
            const numPoints = params.points.numPoints;
            
            // 初始三角形顶点
            const vertices = [
                -1, -1,  0,
                 0,  1,  0,
                 1, -1,  0
            ];
            
            const u1 = vec3.fromValues(vertices[0], vertices[1], vertices[2]);
            const u2 = vec3.fromValues(vertices[3], vertices[4], vertices[5]);
            const u3 = vec3.fromValues(vertices[6], vertices[7], vertices[8]);
            
            let u = vec3.create();
            vec3.add(u, u1, u2);
            let v = vec3.create();
            vec3.add(v, u1, u3);
            
            let p = vec3.create();
            vec3.add(p, u, v);
            vec3.scale(p, p, 0.25);
            
            // 添加初始点
            for (let i = 0; i < 3; i++)
                points.push(p[i]);
            
            // 计算新点
            for (let i = 0; points.length < numPoints * 3; i++) {
                const j = Math.floor(Math.random() * 3);
                vec3.set(u, vertices[j*3], vertices[j*3+1], vertices[j*3+2]);
                vec3.set(v, points[i*3], points[i*3+1], points[i*3+2]);
                
                vec3.add(p, u, v);
                vec3.scale(p, p, 0.5);
                
                for (let k = 0; k < 3; k++)
                    points.push(p[k]);
            }
            
            // 创建缓冲区
            const bufferId = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            
            // 关联属性
            const vPosition = gl.getAttribLocation(program, 'vPosition');
            gl.vertexAttribPointer(vPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);
            
            renderPoints();
        }

        function renderPoints() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.POINTS, 0, params.points.numPoints);
        }

        // 三角形模式演示
        function initTrianglesDemo() {
            program = initShaderProgram('vertex-shader-triangles', 'fragment-shader-triangles');
            if (!program) return;
            
            gl.useProgram(program);
            
            const { vec3 } = glMatrix;
            const points = [];
            const numTimesToSubdivide = params.triangles.numTimesToSubdivide;
            
            // 初始三角形顶点
            const vertices = [
                -1, -1,  0,
                 0,  1,  0,
                 1, -1,  0
            ];
            
            const u = vec3.fromValues(vertices[0], vertices[1], vertices[2]);
            const v = vec3.fromValues(vertices[3], vertices[4], vertices[5]);
            const w = vec3.fromValues(vertices[6], vertices[7], vertices[8]);
            
            divideTriangle(u, v, w, numTimesToSubdivide);
            
            function triangle(a, b, c) {
                points.push(a[0], a[1], a[2]);
                points.push(b[0], b[1], b[2]);
                points.push(c[0], c[1], c[2]);
            }
            
            function divideTriangle(a, b, c, count) {
                if (count === 0) {
                    triangle(a, b, c);
                } else {
                    const ab = vec3.create();
                    vec3.lerp(ab, a, b, 0.5);
                    const bc = vec3.create();
                    vec3.lerp(bc, b, c, 0.5);
                    const ca = vec3.create();
                    vec3.lerp(ca, c, a, 0.5);
                    
                    divideTriangle(a, ab, ca, count-1);
                    divideTriangle(b, bc, ab, count-1);
                    divideTriangle(c, ca, bc, count-1);
                }
            }
            
            // 创建缓冲区
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            
            // 关联属性
            const vPosition = gl.getAttribLocation(program, "vPosition");
            gl.vertexAttribPointer(vPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);
            
            renderTriangles();
        }

        function renderTriangles() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, points.length / 3);
        }

        // 彩色点模式演示
        function initColorDemo() {
            program = initShaderProgram('vertex-shader-color', 'fragment-shader-color');
            if (!program) return;
            
            gl.useProgram(program);
            
            const { vec3 } = glMatrix;
            const points = [];
            const numPoints = params.color.numPoints;
            
            const vertices = [
                -1.0, -1.0, -1.0,
                1.0, -1.0, -1.0,
                0.0, 1.0, 0.0,
                0.0, -1.0, 1.0
            ];
            
            points.push(0.0, 0.0, 0.0);
            
            const u = vec3.create();
            const v = vec3.create();
            const p = vec3.create();
            
            for (let i = 0; points.length < numPoints * 3; i++) {
                const j = Math.floor(Math.random() * 4);
                
                vec3.set(u, points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);
                vec3.set(v, vertices[j * 3], vertices[j * 3 + 1], vertices[j * 3 + 2]);
                vec3.lerp(p, u, v, 0.5);
                
                points.push(p[0], p[1], p[2]);
            }
            
            // 配置WebGL
            gl.enable(gl.DEPTH_TEST);
            
            // 创建缓冲区
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            
            // 关联属性
            const vPosition = gl.getAttribLocation(program, "vPosition");
            gl.vertexAttribPointer(vPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);
            
            renderColor();
        }

        function renderColor() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.drawArrays(gl.POINTS, 0, points.length / 3);
        }

        // 3D演示
        function init3dDemo() {
            program = initShaderProgram('vertex-shader-3d', 'fragment-shader-3d');
            if (!program) return;
            
            gl.useProgram(program);
            
            const { vec3 } = glMatrix;
            const points = [];
            const colors = [];
            const numTimesToSubdivide = params['3d'].numTimesToSubdivide;
            
            // 初始化四面体顶点
            const vertices = [
                0.0000, 0.0000, -1.0000,
                0.0000, 0.9428, 0.3333,
                -0.8165, -0.4714, 0.3333,
                0.8165, -0.4714, 0.3333
            ];
            
            const t = vec3.fromValues(vertices[0], vertices[1], vertices[2]);
            const u = vec3.fromValues(vertices[3], vertices[4], vertices[5]);
            const v = vec3.fromValues(vertices[6], vertices[7], vertices[8]);
            const w = vec3.fromValues(vertices[9], vertices[10], vertices[11]);
            
            divideTetra(t, u, v, w, numTimesToSubdivide);
            
            function triangle(a, b, c, color) {
                const baseColor = [
                    1.0, 0.0, 0.0, 1.0,
                    0.0, 1.0, 0.0, 1.0,
                    0.0, 0.0, 1.0, 1.0, 
                    0.0, 0.0, 0.0, 1.0
                ];
                
                for (let k = 0; k < 4; k++) {
                    colors.push(baseColor[color * 4 + k]);
                }
                for (let k = 0; k < 3; k++)
                    points.push(a[k]);
                
                for (let k = 0; k < 4; k++) {
                    colors.push(baseColor[color * 4 + k]);
                }
                for (let k = 0; k < 3; k++)
                    points.push(b[k]);
                
                for (let k = 0; k < 4; k++) {
                    colors.push(baseColor[color * 4 + k]);
                }
                for (let k = 0; k < 3; k++)
                    points.push(c[k]);
            }
            
            function tetra(a, b, c, d) {
                triangle(a, c, b, 0);
                triangle(a, c, d, 1);
                triangle(a, b, d, 2);
                triangle(b, c, d, 3);
            }
            
            function divideTetra(a, b, c, d, count) {
                if (count === 0) {
                    tetra(a, b, c, d);
                } else {
                    const ab = vec3.create();
                    glMatrix.vec3.lerp(ab, a, b, 0.5);
                    const ac = vec3.create();
                    glMatrix.vec3.lerp(ac, a, c, 0.5);
                    const ad = vec3.create();
                    glMatrix.vec3.lerp(ad, a, d, 0.5);
                    const bc = vec3.create();
                    glMatrix.vec3.lerp(bc, b, c, 0.5);
                    const bd = vec3.create();
                    glMatrix.vec3.lerp(bd, b, d, 0.5);
                    const cd = vec3.create();
                    glMatrix.vec3.lerp(cd, c, d, 0.5);
                    
                    --count;
                    
                    divideTetra(a, ab, ac, ad, count);
                    divideTetra(ab, b, bc, bd, count);
                    divideTetra(ac, bc, c, cd, count);
                    divideTetra(ad, bd, cd, d, count);
                }
            }
            
            // 配置WebGL
            gl.enable(gl.DEPTH_TEST);
            
            // 创建顶点缓冲区
            const vBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            
            const vPosition = gl.getAttribLocation(program, "vPosition");
            gl.vertexAttribPointer(vPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);
            
            // 创建颜色缓冲区
            const cBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            
            const aColor = gl.getAttribLocation(program, "aColor");
            gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aColor);
            
            render3d();
        }

        function render3d() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, points.length / 3);
        }

        // 三角形细分演示
        function initTessellationDemo() {
            program = initShaderProgram('vertex-shader-tessellation', 'fragment-shader-tessellation');
            if (!program) return;
            
            gl.useProgram(program);
            
            const { vec3 } = glMatrix;
            const points = [];
            const numTimesToSubdivide = params.tessellation.numTimesToSubdivide;
            const theta = params.tessellation.theta;
            const twist = params.tessellation.twist;
            const radius = params.tessellation.radius;
            
            // 初始化三角形顶点
            const vertices = [
                radius * Math.cos(90 * Math.PI / 180.0), radius * Math.sin(90 * Math.PI / 180.0),  0,
                radius * Math.cos(210 * Math.PI / 180.0), radius * Math.sin(210 * Math.PI / 180.0),  0,
                radius * Math.cos(-30 * Math.PI / 180.0), radius * Math.sin(-30 * Math.PI / 180.0),  0
            ];
            
            const u = vec3.fromValues(vertices[0], vertices[1], vertices[2]);
            const v = vec3.fromValues(vertices[3], vertices[4], vertices[5]);
            const w = vec3.fromValues(vertices[6], vertices[7], vertices[8]);
            
            divideTriangle(u, v, w, numTimesToSubdivide);
            
            function tessellaTriangle(a, b, c) {
                const zerovec3 = vec3.create();
                vec3.zero(zerovec3);
                const radian = theta * Math.PI / 180.0;
                
                const a_new = vec3.create();
                const b_new = vec3.create();
                const c_new = vec3.create();
                
                if (twist === false) {
                    vec3.rotateZ(a_new, a, zerovec3, radian);
                    vec3.rotateZ(b_new, b, zerovec3, radian);
                    vec3.rotateZ(c_new, c, zerovec3, radian);
                    
                    points.push(a_new[0], a_new[1], a_new[2]);
                    points.push(b_new[0], b_new[1], b_new[2]);
                    points.push(b_new[0], b_new[1], b_new[2]);
                    points.push(c_new[0], c_new[1], c_new[2]);
                    points.push(c_new[0], c_new[1], c_new[2]);
                    points.push(a_new[0], a_new[1], a_new[2]);
                } else {
                    const d_a = Math.sqrt(a[0] * a[0] + a[1] * a[1]);
                    const d_b = Math.sqrt(b[0] * b[0] + b[1] * b[1]);
                    const d_c = Math.sqrt(c[0] * c[0] + c[1] * c[1]);
                    
                    vec3.set(a_new, 
                        a[0] * Math.cos(d_a * radian) - a[1] * Math.sin(d_a * radian), 
                        a[0] * Math.sin(d_a * radian) + a[1] * Math.cos(d_a * radian), 0);
                    vec3.set(b_new, 
                        b[0] * Math.cos(d_b * radian) - b[1] * Math.sin(d_b * radian),
                        b[0] * Math.sin(d_b * radian) + b[1] * Math.cos(d_b * radian), 0);
                    vec3.set(c_new, 
                        c[0] * Math.cos(d_c * radian) - c[1] * Math.sin(d_c * radian),
                        c[0] * Math.sin(d_c * radian) + c[1] * Math.cos(d_c * radian), 0);
                    
                    points.push(a_new[0], a_new[1], a_new[2]);
                    points.push(b_new[0], b_new[1], b_new[2]);
                    points.push(b_new[0], b_new[1], b_new[2]);
                    points.push(c_new[0], c_new[1], c_new[2]);
                    points.push(c_new[0], c_new[1], c_new[2]);
                    points.push(a_new[0], a_new[1], a_new[2]);
                }
            }
            
            function divideTriangle(a, b, c, count) {
                if (count === 0) {
                    tessellaTriangle(a, b, c);
                } else {
                    const ab = vec3.create();
                    vec3.lerp(ab, a, b, 0.5);
                    const bc = vec3.create();
                    vec3.lerp(bc, b, c, 0.5);
                    const ca = vec3.create();
                    vec3.lerp(ca, c, a, 0.5);
                    
                    divideTriangle(a, ab, ca, count-1);
                    divideTriangle(ab, b, bc, count-1);
                    divideTriangle(ca, bc, c, count-1);
                    divideTriangle(ab, bc, ca, count-1);
                }
            }
            
            // 创建缓冲区
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            
            // 关联属性
            const vPosition = gl.getAttribLocation(program, "vPosition");
            gl.vertexAttribPointer(vPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);
            
            renderTessellation();
        }

        function renderTessellation() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.LINES, 0, points.length / 3);
        }
    </script>
</body>
</html>
