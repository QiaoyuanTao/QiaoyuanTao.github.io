<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Sierpinski Gasket 实验</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .description {
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .canvas-container {
            flex: 1;
            min-width: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
        }
        
        .controls {
            flex: 0 0 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        canvas {
            width: 100%;
            height: 500px;
            background: #000;
            border-radius: 5px;
            display: block;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 8px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        select, input[type="range"] {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            margin-bottom: 15px;
        }
        
        input[type="range"] {
            padding: 0;
            height: 30px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .checkbox-group input {
            margin-right: 10px;
            transform: scale(1.2);
        }
        
        .value-display {
            display: flex;
            justify-content: space-between;
            margin-top: -10px;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }
        
        button {
            width: 100%;
            padding: 12px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background 0.3s;
            margin-top: 10px;
        }
        
        button:hover {
            background: #3a7bc8;
        }
        
        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .info-panel h2 {
            margin-bottom: 15px;
        }
        
        .info-panel p {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        @media (max-width: 900px) {
            .content {
                flex-direction: column;
            }
            
            .canvas-container, .controls {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>WebGL Sierpinski Gasket 实验</h1>
            <p class="description">
                本实验展示了多种Sierpinski Gasket实现方法：二维三角形细分、三维四面体细分、线框模式、固定角度旋转和基于距离的旋转效果。
                您可以通过下面的控件切换不同模式并调整参数。
            </p>
        </header>
        
        <div class="content">
            <div class="canvas-container">
                <h2 id="demo-title">二维Sierpinski Gasket</h2>
                <canvas id="gl-canvas" width="600" height="600">
                    您的浏览器不支持HTML5 canvas元素
                </canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h2>模式选择</h2>
                    <label for="demo-select">选择模式:</label>
                    <select id="demo-select">
                        <option value="gasket2d">二维Sierpinski Gasket</option>
                        <option value="gasket3d">三维Sierpinski Gasket</option>
                        <option value="wireframe">线框模式三角形细分</option>
                        <option value="rotation">固定角度旋转</option>
                        <option value="distance-rotation">基于距离的旋转</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <h2>参数控制</h2>
                    
                    <div id="subdivision-controls">
                        <label for="subdivision-level">细分级别 (0-7):</label>
                        <input type="range" id="subdivision-level" min="0" max="7" value="3" step="1">
                        <div class="value-display">
                            <span>0</span>
                            <span id="subdivision-level-value">3</span>
                            <span>7</span>
                        </div>
                    </div>
                    
                    <div id="rotation-controls" style="display: none;">
                        <label for="theta">旋转角度 (θ):</label>
                        <input type="range" id="theta" min="0" max="360" value="60" step="1">
                        <div class="value-display">
                            <span>0°</span>
                            <span id="theta-value">60°</span>
                            <span>360°</span>
                        </div>
                    </div>
                    
                    <div id="distance-controls" style="display: none;">
                        <label for="distance-theta">基于距离的旋转角度:</label>
                        <input type="range" id="distance-theta" min="0" max="360" value="60" step="1">
                        <div class="value-display">
                            <span>0°</span>
                            <span id="distance-theta-value">60°</span>
                            <span>360°</span>
                        </div>
                    </div>
                </div>
                
                <button id="reset-button">重置参数</button>
            </div>
        </div>
        
        <div class="info-panel">
            <h2>实验说明</h2>
            <p><strong>二维Sierpinski Gasket</strong>：通过递归细分三角形生成经典的分形图案。</p>
            <p><strong>三维Sierpinski Gasket</strong>：在三维空间中通过递归细分四面体生成分形图案。</p>
            <p><strong>线框模式三角形细分</strong>：使用线框模式展示三角形细分过程。</p>
            <p><strong>固定角度旋转</strong>：所有三角形绕原点旋转固定角度。</p>
            <p><strong>基于距离的旋转</strong>：每个三角形的旋转角度与其到原点的距离相关。</p>
            <p>通过调整细分级别和旋转角度，可以观察不同参数下的图案变化。</p>
        </div>
    </div>

    <!-- 主应用程序 -->
    <script>
        "use strict";

        // 全局变量
        let gl, canvas;
        let currentDemo = 'gasket2d';
        let program;
        let points = [];
        let colors = [];
        
        // 演示参数
        const params = {
            gasket2d: {
                numTimesToSubdivide: 3
            },
            gasket3d: {
                numTimesToSubdivide: 3
            },
            wireframe: {
                numTimesToSubdivide: 3
            },
            rotation: {
                numTimesToSubdivide: 3,
                theta: 60
            },
            'distance-rotation': {
                numTimesToSubdivide: 3,
                theta: 60
            }
        };

        // 着色器代码
        const vertexShaderSource = `#version 300 es
        in vec4 vPosition;
        void main(){
            gl_Position = vPosition;
        }`;

        const fragmentShaderSource = `#version 300 es
        precision mediump float;
        out vec4 fColor;
        void main(){
            fColor = vec4( 1.0, 0.0, 0.0, 1.0 );
        }`;

        const vertexShaderSource3D = `#version 300 es
        in vec3 vPosition;
        in vec4 aColor;
        out vec4 vColor;

        void main(){
            gl_Position = vec4( vPosition, 1.0 );
            vColor = aColor;
        }`;

        const fragmentShaderSource3D = `#version 300 es
        precision mediump float;
        
        in vec4 vColor;
        out vec4 fColor;
        void main(){
            fColor = vColor;
        }`;

        // 初始化函数
        window.onload = function init() {
            canvas = document.getElementById("gl-canvas");
            
            // 获取WebGL2上下文
            gl = canvas.getContext("webgl2");
            if (!gl) {
                alert("WebGL 2.0 不可用");
                return;
            }
            
            // 设置初始演示
            setupDemo('gasket2d');
            
            // 设置事件监听器
            setupEventListeners();
        };

        // 设置事件监听器
        function setupEventListeners() {
            // 演示选择
            document.getElementById('demo-select').addEventListener('change', function(e) {
                setupDemo(e.target.value);
            });
            
            // 参数控制
            document.getElementById('subdivision-level').addEventListener('input', function(e) {
                const value = parseInt(e.target.value);
                document.getElementById('subdivision-level-value').textContent = value;
                
                // 更新所有模式的细分级别
                for (let key in params) {
                    params[key].numTimesToSubdivide = value;
                }
                
                setupDemo(currentDemo);
            });
            
            document.getElementById('theta').addEventListener('input', function(e) {
                const value = parseInt(e.target.value);
                document.getElementById('theta-value').textContent = value + '°';
                params.rotation.theta = value;
                if (currentDemo === 'rotation') {
                    setupDemo(currentDemo);
                }
            });
            
            document.getElementById('distance-theta').addEventListener('input', function(e) {
                const value = parseInt(e.target.value);
                document.getElementById('distance-theta-value').textContent = value + '°';
                params['distance-rotation'].theta = value;
                if (currentDemo === 'distance-rotation') {
                    setupDemo(currentDemo);
                }
            });
            
            // 重置按钮
            document.getElementById('reset-button').addEventListener('click', function() {
                resetParams();
                setupDemo(currentDemo);
            });
        }

        // 重置参数
        function resetParams() {
            params.gasket2d.numTimesToSubdivide = 3;
            params.gasket3d.numTimesToSubdivide = 3;
            params.wireframe.numTimesToSubdivide = 3;
            params.rotation.numTimesToSubdivide = 3;
            params.rotation.theta = 60;
            params['distance-rotation'].numTimesToSubdivide = 3;
            params['distance-rotation'].theta = 60;
            
            // 更新UI
            document.getElementById('subdivision-level').value = 3;
            document.getElementById('subdivision-level-value').textContent = '3';
            document.getElementById('theta').value = 60;
            document.getElementById('theta-value').textContent = '60°';
            document.getElementById('distance-theta').value = 60;
            document.getElementById('distance-theta-value').textContent = '60°';
        }

        // 设置演示
        function setupDemo(demoType) {
            currentDemo = demoType;
            
            // 更新标题
            const titles = {
                gasket2d: '二维Sierpinski Gasket',
                gasket3d: '三维Sierpinski Gasket',
                wireframe: '线框模式三角形细分',
                rotation: '固定角度旋转',
                'distance-rotation': '基于距离的旋转'
            };
            document.getElementById('demo-title').textContent = titles[demoType];
            
            // 显示/隐藏相关控件
            document.getElementById('subdivision-controls').style.display = 'block';
            document.getElementById('rotation-controls').style.display = 
                demoType === 'rotation' ? 'block' : 'none';
            document.getElementById('distance-controls').style.display = 
                demoType === 'distance-rotation' ? 'block' : 'none';
            
            // 设置WebGL
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(1.0, 1.0, 1.0, 1.0);
            
            // 根据演示类型调用相应的初始化函数
            switch(demoType) {
                case 'gasket2d':
                    initGasket2D();
                    break;
                case 'gasket3d':
                    initGasket3D();
                    break;
                case 'wireframe':
                    initWireframe();
                    break;
                case 'rotation':
                    initRotation();
                    break;
                case 'distance-rotation':
                    initDistanceRotation();
                    break;
            }
        }

        // 初始化着色器程序
        function initShaderProgram(vertexSource, fragmentSource) {
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexSource);
            gl.compileShader(vertexShader);
            
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error('顶点着色器编译错误:', gl.getShaderInfoLog(vertexShader));
                return null;
            }
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentSource);
            gl.compileShader(fragmentShader);
            
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error('片段着色器编译错误:', gl.getShaderInfoLog(fragmentShader));
                return null;
            }
            
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('着色器程序链接错误:', gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            
            return shaderProgram;
        }

        // 二维Sierpinski Gasket
        function initGasket2D() {
            program = initShaderProgram(vertexShaderSource, fragmentShaderSource);
            if (!program) {
                console.error("无法初始化着色器程序");
                return;
            }
            
            gl.useProgram(program);
            
            points = [];
            const numTimesToSubdivide = params.gasket2d.numTimesToSubdivide;
            
            // 初始三角形顶点
            const vertices = [
                -1, -1,  0,
                 0,  1,  0,
                 1, -1,  0
            ];

            divideTriangle(
                [vertices[0], vertices[1], vertices[2]],
                [vertices[3], vertices[4], vertices[5]],
                [vertices[6], vertices[7], vertices[8]],
                numTimesToSubdivide
            );

            function triangle(a, b, c) {
                points.push(a[0], a[1], a[2]);
                points.push(b[0], b[1], b[2]);
                points.push(c[0], c[1], c[2]);
            }

            function divideTriangle(a, b, c, count) {
                if (count === 0) {
                    triangle(a, b, c);
                } else {
                    // 计算中点
                    const ab = [
                        (a[0] + b[0]) / 2,
                        (a[1] + b[1]) / 2,
                        (a[2] + b[2]) / 2
                    ];
                    const bc = [
                        (b[0] + c[0]) / 2,
                        (b[1] + c[1]) / 2,
                        (b[2] + c[2]) / 2
                    ];
                    const ca = [
                        (c[0] + a[0]) / 2,
                        (c[1] + a[1]) / 2,
                        (c[2] + a[2]) / 2
                    ];
                    
                    // 三个新三角形
                    divideTriangle(a, ab, ca, count-1);
                    divideTriangle(b, bc, ab, count-1);
                    divideTriangle(c, ca, bc, count-1);
                }
            }
            
            // 创建缓冲区
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            
            // 关联属性
            const vPosition = gl.getAttribLocation(program, "vPosition");
            gl.vertexAttribPointer(vPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);
            
            renderGasket2D();
        }

        function renderGasket2D() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            if (points.length > 0) {
                gl.drawArrays(gl.TRIANGLES, 0, points.length / 3);
            }
        }

        // 三维Sierpinski Gasket
        function initGasket3D() {
            program = initShaderProgram(vertexShaderSource3D, fragmentShaderSource3D);
            if (!program) {
                console.error("无法初始化着色器程序");
                return;
            }
            
            gl.useProgram(program);
            
            points = [];
            colors = [];
            const numTimesToSubdivide = params.gasket3d.numTimesToSubdivide;
            
            // 初始化四面体顶点
            const vertices = [
                0.0000, 0.0000, -1.0000,
                0.0000, 0.9428, 0.3333,
                -0.8165, -0.4714, 0.3333,
                0.8165, -0.4714, 0.3333
            ];
            
            const t = [vertices[0], vertices[1], vertices[2]];
            const u = [vertices[3], vertices[4], vertices[5]];
            const v = [vertices[6], vertices[7], vertices[8]];
            const w = [vertices[9], vertices[10], vertices[11]];
            
            divideTetra(t, u, v, w, numTimesToSubdivide);
            
            function triangle(a, b, c, color) {
                const baseColor = [
                    [1.0, 0.0, 0.0, 1.0],  // 红色
                    [0.0, 1.0, 0.0, 1.0],  // 绿色
                    [0.0, 0.0, 1.0, 1.0],  // 蓝色
                    [1.0, 1.0, 0.0, 1.0]   // 黄色
                ];
                
                // 添加三个顶点和对应的颜色
                for (let k = 0; k < 3; k++) points.push(a[k]);
                for (let k = 0; k < 4; k++) colors.push(baseColor[color][k]);
                
                for (let k = 0; k < 3; k++) points.push(b[k]);
                for (let k = 0; k < 4; k++) colors.push(baseColor[color][k]);
                
                for (let k = 0; k < 3; k++) points.push(c[k]);
                for (let k = 0; k < 4; k++) colors.push(baseColor[color][k]);
            }
            
            function tetra(a, b, c, d) {
                triangle(a, c, b, 0);
                triangle(a, c, d, 1);
                triangle(a, b, d, 2);
                triangle(b, c, d, 3);
            }
            
            function divideTetra(a, b, c, d, count) {
                if (count === 0) {
                    tetra(a, b, c, d);
                } else {
                    // 计算中点
                    const ab = [
                        (a[0] + b[0]) / 2,
                        (a[1] + b[1]) / 2,
                        (a[2] + b[2]) / 2
                    ];
                    const ac = [
                        (a[0] + c[0]) / 2,
                        (a[1] + c[1]) / 2,
                        (a[2] + c[2]) / 2
                    ];
                    const ad = [
                        (a[0] + d[0]) / 2,
                        (a[1] + d[1]) / 2,
                        (a[2] + d[2]) / 2
                    ];
                    const bc = [
                        (b[0] + c[0]) / 2,
                        (b[1] + c[1]) / 2,
                        (b[2] + c[2]) / 2
                    ];
                    const bd = [
                        (b[0] + d[0]) / 2,
                        (b[1] + d[1]) / 2,
                        (b[2] + d[2]) / 2
                    ];
                    const cd = [
                        (c[0] + d[0]) / 2,
                        (c[1] + d[1]) / 2,
                        (c[2] + d[2]) / 2
                    ];
                    
                    --count;
                    
                    divideTetra(a, ab, ac, ad, count);
                    divideTetra(ab, b, bc, bd, count);
                    divideTetra(ac, bc, c, cd, count);
                    divideTetra(ad, bd, cd, d, count);
                }
            }
            
            // 配置WebGL
            gl.enable(gl.DEPTH_TEST);
            
            // 创建顶点缓冲区
            const vBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            
            const vPosition = gl.getAttribLocation(program, "vPosition");
            gl.vertexAttribPointer(vPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);
            
            // 创建颜色缓冲区
            const cBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            
            const aColor = gl.getAttribLocation(program, "aColor");
            gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aColor);
            
            renderGasket3D();
        }

        function renderGasket3D() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            if (points.length > 0) {
                gl.drawArrays(gl.TRIANGLES, 0, points.length / 3);
            }
        }

        // 线框模式三角形细分
        function initWireframe() {
            program = initShaderProgram(vertexShaderSource, fragmentShaderSource);
            if (!program) {
                console.error("无法初始化着色器程序");
                return;
            }
            
            gl.useProgram(program);
            
            points = [];
            const numTimesToSubdivide = params.wireframe.numTimesToSubdivide;
            
            // 初始化三角形顶点
            const vertices = [
                -1, -1,  0,
                 0,  1,  0,
                 1, -1,  0
            ];

            divideTriangle(
                [vertices[0], vertices[1], vertices[2]],
                [vertices[3], vertices[4], vertices[5]],
                [vertices[6], vertices[7], vertices[8]],
                numTimesToSubdivide
            );

            function triangle(a, b, c) {
                // 添加线框
                points.push(a[0], a[1], a[2]);
                points.push(b[0], b[1], b[2]);
                
                points.push(b[0], b[1], b[2]);
                points.push(c[0], c[1], c[2]);
                
                points.push(c[0], c[1], c[2]);
                points.push(a[0], a[1], a[2]);
            }

            function divideTriangle(a, b, c, count) {
                if (count === 0) {
                    triangle(a, b, c);
                } else {
                    // 计算中点
                    const ab = [
                        (a[0] + b[0]) / 2,
                        (a[1] + b[1]) / 2,
                        (a[2] + b[2]) / 2
                    ];
                    const bc = [
                        (b[0] + c[0]) / 2,
                        (b[1] + c[1]) / 2,
                        (b[2] + c[2]) / 2
                    ];
                    const ca = [
                        (c[0] + a[0]) / 2,
                        (c[1] + a[1]) / 2,
                        (c[2] + a[2]) / 2
                    ];
                    
                    // 三个新三角形
                    divideTriangle(a, ab, ca, count-1);
                    divideTriangle(b, bc, ab, count-1);
                    divideTriangle(c, ca, bc, count-1);
                }
            }
            
            // 创建缓冲区
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            
            // 关联属性
            const vPosition = gl.getAttribLocation(program, "vPosition");
            gl.vertexAttribPointer(vPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);
            
            renderWireframe();
        }

        function renderWireframe() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            if (points.length > 0) {
                gl.drawArrays(gl.LINES, 0, points.length / 3);
            }
        }

        // 固定角度旋转
        function initRotation() {
            program = initShaderProgram(vertexShaderSource, fragmentShaderSource);
            if (!program) {
                console.error("无法初始化着色器程序");
                return;
            }
            
            gl.useProgram(program);
            
            points = [];
            const numTimesToSubdivide = params.rotation.numTimesToSubdivide;
            const theta = params.rotation.theta;
            
            // 初始化三角形顶点
            const vertices = [
                -1, -1,  0,
                 0,  1,  0,
                 1, -1,  0
            ];

            divideTriangle(
                [vertices[0], vertices[1], vertices[2]],
                [vertices[3], vertices[4], vertices[5]],
                [vertices[6], vertices[7], vertices[8]],
                numTimesToSubdivide
            );

            function triangle(a, b, c) {
                const radian = theta * Math.PI / 180.0;
                
                // 旋转点a
                const a_new = [
                    a[0] * Math.cos(radian) - a[1] * Math.sin(radian),
                    a[0] * Math.sin(radian) + a[1] * Math.cos(radian),
                    0
                ];
                
                // 旋转点b
                const b_new = [
                    b[0] * Math.cos(radian) - b[1] * Math.sin(radian),
                    b[0] * Math.sin(radian) + b[1] * Math.cos(radian),
                    0
                ];
                
                // 旋转点c
                const c_new = [
                    c[0] * Math.cos(radian) - c[1] * Math.sin(radian),
                    c[0] * Math.sin(radian) + c[1] * Math.cos(radian),
                    0
                ];
                
                // 添加线框
                points.push(a_new[0], a_new[1], a_new[2]);
                points.push(b_new[0], b_new[1], b_new[2]);
                
                points.push(b_new[0], b_new[1], b_new[2]);
                points.push(c_new[0], c_new[1], c_new[2]);
                
                points.push(c_new[0], c_new[1], c_new[2]);
                points.push(a_new[0], a_new[1], a_new[2]);
            }

            function divideTriangle(a, b, c, count) {
                if (count === 0) {
                    triangle(a, b, c);
                } else {
                    // 计算中点
                    const ab = [
                        (a[0] + b[0]) / 2,
                        (a[1] + b[1]) / 2,
                        (a[2] + b[2]) / 2
                    ];
                    const bc = [
                        (b[0] + c[0]) / 2,
                        (b[1] + c[1]) / 2,
                        (b[2] + c[2]) / 2
                    ];
                    const ca = [
                        (c[0] + a[0]) / 2,
                        (c[1] + a[1]) / 2,
                        (c[2] + a[2]) / 2
                    ];
                    
                    // 四个新三角形
                    divideTriangle(a, ab, ca, count-1);
                    divideTriangle(ab, b, bc, count-1);
                    divideTriangle(ca, bc, c, count-1);
                    divideTriangle(ab, bc, ca, count-1);
                }
            }
            
            // 创建缓冲区
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            
            // 关联属性
            const vPosition = gl.getAttribLocation(program, "vPosition");
            gl.vertexAttribPointer(vPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);
            
            renderRotation();
        }

        function renderRotation() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            if (points.length > 0) {
                gl.drawArrays(gl.LINES, 0, points.length / 3);
            }
        }

        // 基于距离的旋转
        function initDistanceRotation() {
            program = initShaderProgram(vertexShaderSource, fragmentShaderSource);
            if (!program) {
                console.error("无法初始化着色器程序");
                return;
            }
            
            gl.useProgram(program);
            
            points = [];
            const numTimesToSubdivide = params['distance-rotation'].numTimesToSubdivide;
            const theta = params['distance-rotation'].theta;
            
            // 初始化三角形顶点
            const vertices = [
                -1, -1,  0,
                 0,  1,  0,
                 1, -1,  0
            ];

            divideTriangle(
                [vertices[0], vertices[1], vertices[2]],
                [vertices[3], vertices[4], vertices[5]],
                [vertices[6], vertices[7], vertices[8]],
                numTimesToSubdivide
            );

            function triangle(a, b, c) {
                // 计算每个点到原点的距离
                const d_a = Math.sqrt(a[0] * a[0] + a[1] * a[1]);
                const d_b = Math.sqrt(b[0] * b[0] + b[1] * b[1]);
                const d_c = Math.sqrt(c[0] * c[0] + c[1] * c[1]);
                
                // 根据距离计算旋转角度
                const radian_a = d_a * theta * Math.PI / 180.0;
                const radian_b = d_b * theta * Math.PI / 180.0;
                const radian_c = d_c * theta * Math.PI / 180.0;
                
                // 旋转点a
                const a_new = [
                    a[0] * Math.cos(radian_a) - a[1] * Math.sin(radian_a),
                    a[0] * Math.sin(radian_a) + a[1] * Math.cos(radian_a),
                    0
                ];
                
                // 旋转点b
                const b_new = [
                    b[0] * Math.cos(radian_b) - b[1] * Math.sin(radian_b),
                    b[0] * Math.sin(radian_b) + b[1] * Math.cos(radian_b),
                    0
                ];
                
                // 旋转点c
                const c_new = [
                    c[0] * Math.cos(radian_c) - c[1] * Math.sin(radian_c),
                    c[0] * Math.sin(radian_c) + c[1] * Math.cos(radian_c),
                    0
                ];
                
                // 添加线框
                points.push(a_new[0], a_new[1], a_new[2]);
                points.push(b_new[0], b_new[1], b_new[2]);
                
                points.push(b_new[0], b_new[1], b_new[2]);
                points.push(c_new[0], c_new[1], c_new[2]);
                
                points.push(c_new[0], c_new[1], c_new[2]);
                points.push(a_new[0], a_new[1], a_new[2]);
            }

            function divideTriangle(a, b, c, count) {
                if (count === 0) {
                    triangle(a, b, c);
                } else {
                    // 计算中点
                    const ab = [
                        (a[0] + b[0]) / 2,
                        (a[1] + b[1]) / 2,
                        (a[2] + b[2]) / 2
                    ];
                    const bc = [
                        (b[0] + c[0]) / 2,
                        (b[1] + c[1]) / 2,
                        (b[2] + c[2]) / 2
                    ];
                    const ca = [
                        (c[0] + a[0]) / 2,
                        (c[1] + a[1]) / 2,
                        (c[2] + a[2]) / 2
                    ];
                    
                    // 四个新三角形
                    divideTriangle(a, ab, ca, count-1);
                    divideTriangle(ab, b, bc, count-1);
                    divideTriangle(ca, bc, c, count-1);
                    divideTriangle(ab, bc, ca, count-1);
                }
            }
            
            // 创建缓冲区
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            
            // 关联属性
            const vPosition = gl.getAttribLocation(program, "vPosition");
            gl.vertexAttribPointer(vPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);
            
            renderDistanceRotation();
        }

        function renderDistanceRotation() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            if (points.length > 0) {
                gl.drawArrays(gl.LINES, 0, points.length / 3);
            }
        }
    </script>
</body>
</html>
